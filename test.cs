//
// Copyright (c) Brian Hernandez. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
//

using UnityEngine;

namespace MFlight.Demo
{
    /// <summary>
    /// This is a very demo-ey example of how to interpret the input generated by the
    /// MouseFlightController. The plane flies towards the MouseAimPos automatically in
    /// a similar fashion to how War Thunder's Instructor does it. There are also
    /// keyboard overrides for flight control. It's not perfect, but it works well enough
    /// for an example.
    /// </summary>
    [RequireComponent(typeof(Rigidbody))]
    public class Plane : MonoBehaviour
    {
        [Header("Components")]
        [SerializeField] private MouseFlightController controller = null;

        [Header("Physics")]
        [Tooltip("Force to push plane forwards with")] public float thrust = 50f;
        [Tooltip("Pitch, Yaw, Roll")] public Vector3 turnTorque = new Vector3(90f, 25f, 45f);
        [Tooltip("Multiplier for all forces")] public float forceMult = 1000f;

        [Header("Autopilot")]
        [Tooltip("Sensitivity for autopilot flight.")] public float sensitivity = 5f;
        [Tooltip("Angle at which airplane banks fully into target.")] public float aggressiveTurnAngle = 10f;

        [Header("Input")]
        [SerializeField] [Range(-1f, 1f)] private float pitch = 0f;
        [SerializeField] [Range(-1f, 1f)] private float yaw = 0f;
        [SerializeField] [Range(-1f, 1f)] private float roll = 0f;

        public float Pitch { set { pitch = Mathf.Clamp(value, -1f, 1f); } get { return pitch; } }
        public float Yaw { set { yaw = Mathf.Clamp(value, -1f, 1f); } get { return yaw; } }
        public float Roll { set { roll = Mathf.Clamp(value, -1f, 1f); } get { return roll; } }

        private Rigidbody rigid;

        private bool rollOverride = false;
        private bool pitchOverride = false;

        [Header("Aerodynamic Parameters")]
        [Tooltip("Air density (kg/m^3). 1.225 at sea level.")] public float airDensity = 1.225f;
        [Tooltip("Wing surface area (m^2).")] public float wingArea = 10f; 
        [Tooltip("Base lift coefficient.")] public float baseCL = 0.1f;
        [Tooltip("Base drag coefficient.")] public float baseCD = 0.02f;
        [Tooltip("Max additional lift at high angle of attack.")] public float maxCL = 0.3f;
        [Tooltip("Max additional drag at high angle of attack.")] public float maxCD = 0.3f;

        [Header("Turbulence")]
        [Tooltip("Strength of turbulence forces.")] public float turbulenceStrength = 50f;
        [Tooltip("Frequency of turbulence changes.")]
        public float turbulenceFrequency = 2f; 
        private float turbulenceTimer = 0f;
        private Vector3 turbulenceForce;

        private void Awake()
        {
            rigid = GetComponent<Rigidbody>();

            if (controller == null)
                Debug.LogError(name + ": Plane - Missing reference to MouseFlightController!");
        }

        private void Update()
        {
            // When the player commands their own stick input, it should override what the
            // autopilot is trying to do.
            rollOverride = false;
            pitchOverride = false;

            float keyboardRoll = Input.GetAxis("Horizontal");
            if (Mathf.Abs(keyboardRoll) > .25f)
            {
                rollOverride = true;
            }

            float keyboardPitch = Input.GetAxis("Vertical");
            if (Mathf.Abs(keyboardPitch) > .25f)
            {
                pitchOverride = true;
                rollOverride = true;
            }

            // Calculate the autopilot stick inputs.
            float autoYaw = 0f;
            float autoPitch = 0f;
            float autoRoll = 0f;
            if (controller != null)
                RunAutopilot(controller.MouseAimPos, out autoYaw, out autoPitch, out autoRoll);

            // Use either keyboard or autopilot input.
            yaw = autoYaw;
            pitch = (pitchOverride) ? keyboardPitch : autoPitch;
            roll = (rollOverride) ? keyboardRoll : autoRoll;
        }

        private void RunAutopilot(Vector3 flyTarget, out float yaw, out float pitch, out float roll)
        {
            // This is my usual trick of converting the fly to position to local space.
            // You can derive a lot of information from where the target is relative to self.
            var localFlyTarget = transform.InverseTransformPoint(flyTarget).normalized * sensitivity;
            var angleOffTarget = Vector3.Angle(transform.forward, flyTarget - transform.position);

            // IMPORTANT!
            // These inputs are created proportionally. This means it can be prone to
            // overshooting. The physics in this example are tweaked so that it's not a big
            // issue, but in something with different or more realistic physics this might
            // not be the case. Use of a PID controller for each axis is highly recommended.

            // ====================
            // PITCH AND YAW
            // ====================

            // Yaw/Pitch into the target so as to put it directly in front of the aircraft.
            // A target is directly in front the aircraft if the relative X and Y are both
            // zero. Note this does not handle for the case where the target is directly behind.
            yaw = Mathf.Clamp(localFlyTarget.x, -1f, 1f);
            pitch = -Mathf.Clamp(localFlyTarget.y, -1f, 1f);

            // ====================
            // ROLL
            // ====================

            // Roll is a little special because there are two different roll commands depending
            // on the situation. When the target is off axis, then the plane should roll into it.
            // When the target is directly in front, the plane should fly wings level.

            // An "aggressive roll" is input such that the aircraft rolls into the target so
            // that pitching up (handled above) will put the nose onto the target. This is
            // done by rolling such that the X component of the target's position is zeroed.
            var agressiveRoll = Mathf.Clamp(localFlyTarget.x, -1f, 1f);

            // A "wings level roll" is a roll commands the aircraft to fly wings level.
            // This can be done by zeroing out the Y component of the aircraft's right.
            var wingsLevelRoll = transform.right.y;

            // Blend between auto level and banking into the target.
            var wingsLevelInfluence = Mathf.InverseLerp(0f, aggressiveTurnAngle, angleOffTarget);
            roll = Mathf.Lerp(wingsLevelRoll, agressiveRoll, wingsLevelInfluence);
        }

        private void FixedUpdate()
        {
            // Ultra simple flight where the plane just gets pushed forward and manipulated
            // with torques to turn.
            rigid.AddRelativeForce(Vector3.forward * thrust * forceMult, ForceMode.Force);
            rigid.AddRelativeTorque(new Vector3(turnTorque.x * pitch,
                                                turnTorque.y * yaw,
                                                -turnTorque.z * roll) * forceMult,
                                    ForceMode.Force);
        }

    //     private void FixedUpdate()
    //     {
    //         // Calculate aerodynamic forces
    //         Vector3 velocity = rigid.velocity;
    //         float speed = velocity.magnitude;
    //         if (speed < 0.1f) speed = 0.1f; // Avoid division by zero

    //         // Angle of attack approximation :
    //         // On simplifie en considérant l'angle par rapport à l'avant de l'avion et la direction du flux d'air.
    //         // Dans une simulation plus complète, cela dépendrait de l'orientation du fuselage, des ailes, etc.
    //         // Ici on prend l'angle entre l'avant de l'avion (transform.forward) et la vélocité.
    //         float angleOfAttack = Vector3.Angle(transform.forward, velocity);
    //         // Convertir l'angle en radians pour plus de facilité d'utilisation
    //         float aoaRad = angleOfAttack * Mathf.Deg2Rad;

    //         // Modifier CL et CD en fonction de l'angle d'attaque (modèle très simplifié)
    //         float CL = Mathf.Lerp(baseCL, maxCL, Mathf.Clamp01((angleOfAttack / 15f))); // plus on s'approche de 15°, plus on augmente CL
    //         float CD = Mathf.Lerp(baseCD, maxCD, Mathf.Clamp01((angleOfAttack / 30f))); // la traînée augmente fortement avec l'angle

    //         // Forces aérodynamiques
    //         // Lift perpendiculaire à la direction du flux d'air. Pour simplifier, on considère la portance orientée globalement "vers le haut" de l'avion.
    //         // Cependant, dans un modèle plus complet, la portance serait perpendiculaire à la vélocité relative de l'air sur l'aile.
    //         // Ici, on part du principe que l'avion est à peu près en vol droit.
    //         float q = 0.5f * airDensity * speed * speed; // pression dynamique
    //         float liftForceMagnitude = q * wingArea * CL;
    //         float dragForceMagnitude = q * wingArea * CD;

    //         // La direction de la traînée est opposée à la vitesse
    //         Vector3 dragDirection = -velocity.normalized;
    //         Vector3 velocityDir = velocity.normalized;
    //         // La direction de la portance est approximée comme l'axe "up" de l'avion (transform.up) mais idéalement serait perpendiculaire au vecteur vitesse dans le plan vertical de l'avion.
    //         // Pour plus de réalisme, on pourrait calculer un vecteur lift = Vector3.Cross(velocity, transform.right).normalized si on considère l'aile orientée.
    //         Vector3 liftDirection = Vector3.Cross(velocityDir, transform.right).normalized;

    //         // On ajoute les forces
    //         Vector3 liftForce = liftDirection * liftForceMagnitude;
    //         Vector3 dragForce = dragDirection * dragForceMagnitude;

    //         // Turbulence : force aléatoire changeant régulièrement
    //         turbulenceTimer += Time.fixedDeltaTime;
    //         if (turbulenceTimer > 1f / turbulenceFrequency)
    //         {
    //             turbulenceTimer = 0f;
    //             turbulenceForce = new Vector3(
    //                 Random.Range(-1f, 1f),
    //                 Random.Range(-1f, 1f),
    //                 Random.Range(-1f, 1f)) * turbulenceStrength;
    //         }

    //         // Appliquer la poussée moteur (toujours vers l'avant local)
    //         rigid.AddRelativeForce(Vector3.forward * thrust * forceMult, ForceMode.Force);

    //         // Appliquer la portance, la traînée et la turbulence
    //         rigid.AddForce(liftForce, ForceMode.Force);
    //         rigid.AddForce(dragForce, ForceMode.Force);
    //         rigid.AddForce(turbulenceForce, ForceMode.Force);

    //         // Appliquer les couples pour le contrôle
    //         // On garde la logique existante, mais sachez qu'avec une aérodynamique plus réaliste, il faudrait affiner les couples et leur effet.
    //         rigid.AddRelativeTorque(new Vector3(turnTorque.x * pitch,
    //                                             turnTorque.y * yaw,
    //                                             -turnTorque.z * roll) * forceMult,
    //                                 ForceMode.Force);
    //     }
    // }
}



//
// Copyright (c) Brian Hernandez. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
//

using UnityEngine;
using System.Collections;
using System.Collections.Generic;

namespace MFlight.Demo
{
    /// <summary>
    /// This is a very demo-ey example of how to interpret the input generated by the
    /// MouseFlightController. The plane flies towards the MouseAimPos automatically in
    /// a similar fashion to how War Thunder's Instructor does it. There are also
    /// keyboard overrides for flight control. It's not perfect, but it works well enough
    /// for an example.
    /// </summary>
    [RequireComponent(typeof(Rigidbody))]
    public class Plane : MonoBehaviour
    {
        [Header("Components")]
        [SerializeField] private MouseFlightController controller = null;

        [Header("Physics")]
        [Tooltip("Force to push plane forwards with")] public float thrust = 50f;
        [Tooltip("Pitch, Yaw, Roll")] public Vector3 turnTorque = new Vector3(90f, 25f, 45f);
        [Tooltip("Multiplier for all forces")] public float forceMult = 1000f;

        [Header("Autopilot")]
        [Tooltip("Sensitivity for autopilot flight.")] public float sensitivity = 5f;
        [Tooltip("Angle at which airplane banks fully into target.")] public float aggressiveTurnAngle = 10f;

        [Header("Input")]
        [SerializeField] [Range(-1f, 1f)] private float pitch = 0f;
        [SerializeField] [Range(-1f, 1f)] private float yaw = 0f;
        [SerializeField] [Range(-1f, 1f)] private float roll = 0f;

        public float Pitch { set { pitch = Mathf.Clamp(value, -1f, 1f); } get { return pitch; } }
        public float Yaw { set { yaw = Mathf.Clamp(value, -1f, 1f); } get { return yaw; } }
        public float Roll { set { roll = Mathf.Clamp(value, -1f, 1f); } get { return roll; } }


        [Header("Flight Data")]
        [Tooltip("Maximum thrust the plane engine can provide")]
        public float maxThrust = 100f;

        public float Throttle = 50;
        private Vector3 Velocity;
        private Vector3 lastVelocity;
        private Vector3 LocalVelocity;
        private Vector3 LocalAngularVelocity;
        private Vector3 LocalGForce;

        private float AngleOfAttack;
        private float AngleOfAttackYaw;

        public bool AirbrakeDeployed = false;
        public bool FlapsDeployed = false;

        public float airbrakeDrag = 0.1f;
        public float flapsDrag = 0.2f;

        public AnimationCurve dragRight;
        public AnimationCurve dragLeft;
        public AnimationCurve dragTop;
        public AnimationCurve dragBottom;
        public AnimationCurve dragForward;
        public AnimationCurve dragBack;

        [Header("Aérodynamique Avancée")]
        public float inducedDrag = 0.05f;       // Valeur d'exemple
        public float flapsLiftPower = 0.5f;     // Valeur d'exemple
        public float flapsAOABias = 5f;         // Valeur d'exemple (en degrés probablement)
        public float liftPower = 1.0f;          // Valeur d'exemple
        public AnimationCurve liftAOACurve;
        public AnimationCurve inducedDragCurve;

        [Header("Gouvernes")]
        public float rudderPower = 0.5f;        // Valeur d'exemple
        public AnimationCurve rudderAOACurve;
        public AnimationCurve rudderInducedDragCurve;


        [Header("Contrôles Avancés")]
        public AnimationCurve steeringCurve;    // Courbe déterminant la force de virage en fonction de la vitesse
        public Vector3 controlInput;            // Input de contrôle (pitch, yaw, roll normalisés)
        public float turnSpeed = 45f;           // Vitesse de rotation en degrés/s ou un facteur de vitesse
        public Vector3 turnAcceleration = new Vector3(10f, 10f, 10f); // Accélération angulaire
        public Vector3 EffectiveInput;          // Valeur finale des inputs après corrections

        [Header("Limites G")]
        public float gLimit = 8f;       // exemple : limite G générale
        public float gLimitPitch = 8f; 
        private Rigidbody rigid;
        public float initialSpeed=50;
        private bool rollOverride = false;
        private bool pitchOverride = false;

        private void Awake()
        {
            rigid = GetComponent<Rigidbody>();

            if (controller == null)
                Debug.LogError(name + ": Plane - Missing reference to MouseFlightController!");

        }

        private void Update()
        {
            // When the player commands their own stick input, it should override what the
            // autopilot is trying to do.
            rollOverride = false;
            pitchOverride = false;

            float keyboardRoll = Input.GetAxis("Horizontal");
            if (Mathf.Abs(keyboardRoll) > .1f)
            {
                rollOverride = true;
            }

            float keyboardPitch = Input.GetAxis("Vertical");
            if (Mathf.Abs(keyboardPitch) > .1f)
            {
                pitchOverride = true;
                rollOverride = true;
            }

            // Calculate the autopilot stick inputs.
            float autoYaw = 0f;
            float autoPitch = 0f;
            float autoRoll = 0f;
            if (controller != null)
                RunAutopilot(controller.MouseAimPos, out autoYaw, out autoPitch, out autoRoll);

            // Use either keyboard or autopilot input.
            yaw = autoYaw;
            pitch = (pitchOverride) ? keyboardPitch : autoPitch;
            roll = (rollOverride) ? keyboardRoll : autoRoll;
            controlInput = new Vector3(pitch, yaw, roll);
        }

        private void RunAutopilot(Vector3 flyTarget, out float yaw, out float pitch, out float roll)
        {
            // This is my usual trick of converting the fly to position to local space.
            // You can derive a lot of information from where the target is relative to self.
            var localFlyTarget = transform.InverseTransformPoint(flyTarget).normalized * sensitivity;
            var angleOffTarget = Vector3.Angle(transform.forward, flyTarget - transform.position);

            // IMPORTANT!
            // These inputs are created proportionally. This means it can be prone to
            // overshooting. The physics in this example are tweaked so that it's not a big
            // issue, but in something with different or more realistic physics this might
            // not be the case. Use of a PID controller for each axis is highly recommended.

            // ====================
            // PITCH AND YAW
            // ====================

            // Yaw/Pitch into the target so as to put it directly in front of the aircraft.
            // A target is directly in front the aircraft if the relative X and Y are both
            // zero. Note this does not handle for the case where the target is directly behind.
            yaw = Mathf.Clamp(localFlyTarget.x, -1f, 1f);
            pitch = -Mathf.Clamp(localFlyTarget.y, -1f, 1f);

            // ====================
            // ROLL
            // ====================

            // Roll is a little special because there are two different roll commands depending
            // on the situation. When the target is off axis, then the plane should roll into it.
            // When the target is directly in front, the plane should fly wings level.

            // An "aggressive roll" is input such that the aircraft rolls into the target so
            // that pitching up (handled above) will put the nose onto the target. This is
            // done by rolling such that the X component of the target's position is zeroed.
            var agressiveRoll = Mathf.Clamp(localFlyTarget.x, -1f, 1f);

            // A "wings level roll" is a roll commands the aircraft to fly wings level.
            // This can be done by zeroing out the Y component of the aircraft's right.
            var wingsLevelRoll = transform.right.y;

            // Blend between auto level and banking into the target.
            var wingsLevelInfluence = Mathf.InverseLerp(0f, aggressiveTurnAngle, angleOffTarget);
            roll = Mathf.Lerp(wingsLevelRoll, agressiveRoll, wingsLevelInfluence);
        }

        Vector3 CalculateGForce(Vector3 angularVelocity, Vector3 velocity) {
            //estiamte G Force from angular velocity and velocity
            //Velocity = AngularVelocity * Radius
            //G = Velocity^2 / R
            //G = (Velocity * AngularVelocity * Radius) / Radius
            //G = Velocity * AngularVelocity
            //G = V cross A
            return Vector3.Cross(angularVelocity, velocity);
        }

        Vector3 CalculateGForceLimit(Vector3 input) {
            return Utilities.Scale6(
                input,
                gLimit, gLimitPitch,   // floats
                gLimit, gLimit,        // floats
                gLimit, gLimit         // floats
            ) * 9.81f;
        }

        private float CalculateGLimiter(Vector3 controlInput, Vector3 maxAngularVelocity) {
            if (controlInput.magnitude < 0.01f) {
                return 1;
            }

            //if the player gives input with magnitude less than 1, scale up their input so that magnitude == 1
            var maxInput = controlInput.normalized;

            var limit = CalculateGForceLimit(maxInput);
            var maxGForce = CalculateGForce(Vector3.Scale(maxInput, maxAngularVelocity), LocalVelocity);

            if (maxGForce.magnitude > limit.magnitude) {
                //example:
                //maxGForce = 16G, limit = 8G
                //so this is 8 / 16 or 0.5
                return limit.magnitude / maxGForce.magnitude;
            }
            return 1;
        }
        private float CalculateSteering(float dt, float angularVelocity, float targetVelocity, float acceleration) {
            var error = targetVelocity - angularVelocity;
            var accel = acceleration * dt;
            return Mathf.Clamp(error, -accel, accel);
        }

        private void UpdateSteering(float dt) {
            var speed = Mathf.Max(0, LocalVelocity.z);
            //var steeringPower = steeringCurve.Evaluate(speed);
            var baseSteeringPower = 50f; // valeur minimale
            var steeringPower = baseSteeringPower + steeringCurve.Evaluate(speed);
            var gForceScaling = CalculateGLimiter(controlInput, Vector3.one * (turnSpeed * Mathf.Deg2Rad * steeringPower));

            var factor = turnSpeed * Mathf.Deg2Rad * steeringPower * gForceScaling;
            var targetAV = Vector3.Scale(controlInput, Vector3.one * factor);

            var av = LocalAngularVelocity * Mathf.Rad2Deg;

            var correction = new Vector3(
                CalculateSteering(dt, av.x, targetAV.x, turnAcceleration.x * steeringPower),
                CalculateSteering(dt, av.y, targetAV.y, turnAcceleration.y * steeringPower),
                CalculateSteering(dt, av.z, targetAV.z, turnAcceleration.z * steeringPower)
            );
            Debug.Log("Steering Power: " + steeringPower);

            rigid.AddRelativeTorque(correction * Mathf.Deg2Rad, ForceMode.VelocityChange);    //ignore rigidbody mass

            var correctionInput = new Vector3(
                Mathf.Clamp((targetAV.x - av.x) / turnAcceleration.x, -1, 1),
                Mathf.Clamp((targetAV.y - av.y) / turnAcceleration.y, -1, 1),
                Mathf.Clamp((targetAV.z - av.z) / turnAcceleration.z, -1, 1)
            );

            var effectiveInput = (correctionInput + controlInput) * gForceScaling;

            EffectiveInput = new Vector3(
                Mathf.Clamp(effectiveInput.x, -1, 1),
                Mathf.Clamp(effectiveInput.y, -1, 1),
                Mathf.Clamp(effectiveInput.z, -1, 1)
            );

        }

        Vector3 CalculateLift(float angleOfAttack, Vector3 rightAxis, float liftPower, AnimationCurve aoaCurve, AnimationCurve inducedDragCurve) {
            var liftVelocity = Vector3.ProjectOnPlane(LocalVelocity, rightAxis);    //project velocity onto YZ plane
            var v2 = liftVelocity.sqrMagnitude;                                     //square of velocity

            //lift = velocity^2 * coefficient * liftPower
            //coefficient varies with AOA
            var liftCoefficient = aoaCurve.Evaluate(angleOfAttack * Mathf.Rad2Deg);
            var liftForce = v2 * liftCoefficient * liftPower;

            //lift is perpendicular to velocity
            var liftDirection = Vector3.Cross(liftVelocity.normalized, rightAxis);
            var lift = liftDirection * liftForce;

            //induced drag varies with square of lift coefficient
            var dragForce = liftCoefficient * liftCoefficient;
            var dragDirection = -liftVelocity.normalized;
            var inducedDrag = dragDirection * v2 * dragForce * this.inducedDrag * inducedDragCurve.Evaluate(Mathf.Max(0, LocalVelocity.z));

            return lift + inducedDrag;
        }

        private void UpdateLift() {
            if (LocalVelocity.sqrMagnitude < 1f) return;

            float flapsLiftPower = FlapsDeployed ? this.flapsLiftPower : 0;
            float flapsAOABias = FlapsDeployed ? this.flapsAOABias : 0;

            var liftForce = CalculateLift(
                AngleOfAttack + (flapsAOABias * Mathf.Deg2Rad), Vector3.right,
                liftPower + flapsLiftPower,
                liftAOACurve,
                inducedDragCurve
            );

            var yawForce = CalculateLift(AngleOfAttackYaw, Vector3.up, rudderPower, rudderAOACurve, rudderInducedDragCurve);

            rigid.AddRelativeForce(liftForce);
            rigid.AddRelativeForce(yawForce);
        }
        private void UpdateThrust()
        {
            rigid.AddRelativeForce(Throttle*maxThrust*Vector3.forward);

        }
        private void CalculateState(float dt)
        {
            var invRotation = Quaternion.Inverse(transform.rotation);
            Velocity = rigid.velocity;
            LocalVelocity = invRotation * Velocity;
            LocalAngularVelocity = invRotation * rigid.angularVelocity;
        }

        private void CalculateAngleOfAttack()
        {
            if(LocalVelocity.sqrMagnitude < 0.1f)
            {
                AngleOfAttack = 0;
                AngleOfAttackYaw = 0;
                return ;
            }

            AngleOfAttack = Mathf.Atan2(-LocalVelocity.y,LocalVelocity.z);
            AngleOfAttackYaw = Mathf.Atan2(LocalVelocity.x,LocalVelocity.z);
        }

        private void CalculateGForce(float dt)
        {
            var invRotation = Quaternion.Inverse(rigid.rotation);
            var acceleration = (Velocity - lastVelocity) / dt;
            LocalGForce = invRotation * acceleration;
            lastVelocity = Velocity;
        }

        private void UpdateDrag()
        {
            var lv = LocalVelocity;
            var lv2 = lv.sqrMagnitude;  //velocity squared

            float airbrakeDrag = AirbrakeDeployed ? this.airbrakeDrag : 0;
            float flapsDrag = FlapsDeployed ? this.flapsDrag : 0;

            //calculate coefficient of drag depending on direction on velocity
            var coefficient = Utilities.Scale6(
                lv.normalized,
                dragRight.Evaluate(Mathf.Abs(lv.x)), dragLeft.Evaluate(Mathf.Abs(lv.x)),                
                dragTop.Evaluate(Mathf.Abs(lv.y)), dragBottom.Evaluate(Mathf.Abs(lv.y)),
                dragForward.Evaluate(Mathf.Abs(lv.z)) + airbrakeDrag + flapsDrag,   //include extra drag for forward coefficient
                dragBack.Evaluate(Mathf.Abs(lv.z))
            );

            Debug.Log("Input to dragRight: " + Mathf.Abs(lv.x));
            Debug.Log("Input to dragLeft: " + Mathf.Abs(lv.x));
            Debug.Log("Input to dragTop: " + Mathf.Abs(lv.y));
            Debug.Log("Input to dragBottom: " + Mathf.Abs(lv.y));
            Debug.Log("Input to dragForward: " + Mathf.Abs(lv.z));
            Debug.Log("Input to dragBack: " + Mathf.Abs(lv.z));


            var drag = coefficient.magnitude * lv2 * -lv.normalized;    //drag is opposite direction of velocity

            rigid.AddRelativeForce(drag);
        }

        private void FixedUpdate()
        {
            float dt = Time.fixedDeltaTime;

            //calculate at start, to capture any changes that happened externally
            CalculateState(dt);
            CalculateAngleOfAttack();
            CalculateGForce(dt);
           // UpdateFlaps();

            //UpdateThrottle(dt);
            UpdateThrust();
            UpdateLift();
            UpdateSteering(dt);

            UpdateDrag();


            //calculate at end, to capture any changes that happened internally 
            

        }
    
    }
}
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

namespace MFlight.Demo
{
    [RequireComponent(typeof(Rigidbody))]
    public class Plane : MonoBehaviour
    {
        // --------------------------------------------------
        // Inspector Fields
        // --------------------------------------------------

        [Header("Components")]
        [SerializeField] private MouseFlightController controller = null;

        [Header("Physics")]
        [Tooltip("Base forward thrust force")]
        public float thrust = 50f;
        [Tooltip("Pitch, Yaw, Roll torque values")]
        public Vector3 turnTorque = new Vector3(90f, 25f, 45f);
        [Tooltip("Multiplier for all forces")]
        public float forceMult = 1000f;
        [Tooltip("Maximum thrust the engine can provide")]
        public float maxThrust = 1000f;

        [Header("Autopilot")]
        [Tooltip("Sensitivity for autopilot control")]
        public float sensitivity = 5f;
        [Tooltip("Angle at which the plane banks fully into the target")]
        public float aggressiveTurnAngle = 10f;

        [Header("Input")]
        [SerializeField, Range(-1f, 1f)] private float pitch = 0f;
        [SerializeField, Range(-1f, 1f)] private float yaw = 0f;
        [SerializeField, Range(-1f, 1f)] private float roll = 0f;

        [Header("Advanced Aerodynamics")]
        [Tooltip("Base lift power")]
        public float liftPower = 1.0f;        
        [Tooltip("Additional lift power from flaps")]
        public float flapsLiftPower = 0.5f;   
        [Tooltip("Flaps Angle of Attack bias (in degrees)")]
        public float flapsAOABias = 5f;       
        [Tooltip("Rudder power (yaw axis)")]
        public float rudderPower = 0.5f;       

        [Header("Flight Controls")]
        [Tooltip("Normalized control input (pitch, yaw, roll)")]
        public Vector3 controlInput;
        [Tooltip("Target turn speed in deg/s or similar factor")]
        public Vector3 turnSpeed;
        [Tooltip("Angular acceleration values")]
        public Vector3 turnAcceleration;
        [Tooltip("Effective input after G-limit and corrections")]
        public Vector3 EffectiveInput;

        [Header("G-Limit Settings")]
        [Tooltip("General G-limit")]
        public float gLimit;
        [Tooltip("G-limit specifically for pitch axis")]
        public float gLimitPitch;

        [Header("Additional Drag Settings")]
        [Tooltip("Extra drag from airbrakes")]
        public float airbrakeDrag = 0.1f;
        [Tooltip("Extra drag from flaps")]
        public float flapsDrag = 0.2f;
        [Tooltip("Angular drag coefficients")]
        public Vector3 angularDrag;

        // --------------------------------------------------
        // Private Fields
        // --------------------------------------------------

        private Rigidbody rigid;
        private bool rollOverride = false;
        private bool pitchOverride = false;
        private bool Dead = false;
        private float flapsRetractSpeed = 2.0f;

        // State variables
        private Vector3 Velocity;
        private Vector3 lastVelocity;
        private Vector3 LocalVelocity;
        private Vector3 LocalAngularVelocity;
        private Vector3 LocalGForce;
        private float AngleOfAttack;
        private float AngleOfAttackYaw;

        // Deployable states
        public bool AirbrakeDeployed = false;
        public bool FlapsDeployed = false;

        // --------------------------------------------------
        // Properties
        // --------------------------------------------------

        public float Pitch 
        { 
            set { pitch = Mathf.Clamp(value, -1f, 1f); } 
            get { return pitch; } 
        }

        public float Yaw 
        { 
            set { yaw = Mathf.Clamp(value, -1f, 1f); } 
            get { return yaw; } 
        }

        public float Roll 
        { 
            set { roll = Mathf.Clamp(value, -1f, 1f); } 
            get { return roll; } 
        }

        // --------------------------------------------------
        // Unity Lifecycle
        // --------------------------------------------------

        private void Awake()
        {
            rigid = GetComponent<Rigidbody>();

            if (controller == null)
                Debug.LogError(name + ": Plane - Missing reference to MouseFlightController!");
        }

        private void Update()
        {
            HandlePlayerInput();
        }

        private void FixedUpdate()
        {
            float dt = Time.fixedDeltaTime;

            // Calculate state before applying forces
            CalculateState(dt);
            CalculateAngleOfAttack();
            CalculateGForce(dt);
            
            // Updates and physics
            UpdateFlaps();
            UpdateThrust();
            UpdateLift();
            UpdateSteering(dt);
            UpdateDrag();
            UpdateAngularDrag();

            // Recalculate state after updates
            CalculateState(dt);
        }

        // --------------------------------------------------
        // Input Handling
        // --------------------------------------------------

        private void HandlePlayerInput()
        {
            rollOverride = false;
            pitchOverride = false;

            float keyboardRoll = Input.GetAxis("Horizontal");
            if (Mathf.Abs(keyboardRoll) > 0.25f)
            {
                rollOverride = true;
            }

            float keyboardPitch = Input.GetAxis("Vertical");
            if (Mathf.Abs(keyboardPitch) > 0.25f)
            {
                pitchOverride = true;
                rollOverride = true;
            }

            float autoYaw = 0f;
            float autoPitch = 0f;
            float autoRoll = 0f;
            if (controller != null)
            {
                RunAutopilot(controller.MouseAimPos, out autoYaw, out autoPitch, out autoRoll);
            }

            // Choose between autopilot and player input
            yaw = autoYaw;
            pitch = pitchOverride ? keyboardPitch : autoPitch;
            roll = rollOverride ? keyboardRoll : autoRoll;
            controlInput = new Vector3(pitch, yaw, roll);
        }

        private void RunAutopilot(Vector3 flyTarget, out float yaw, out float pitch, out float roll)
        {
            // Convert target position to local space
            var localFlyTarget = transform.InverseTransformPoint(flyTarget).normalized * sensitivity;
            var angleOffTarget = Vector3.Angle(transform.forward, flyTarget - transform.position);

            // Yaw & Pitch
            yaw = Mathf.Clamp(localFlyTarget.x, -1f, 1f);
            pitch = -Mathf.Clamp(localFlyTarget.y, -1f, 1f);

            // Roll logic
            var agressiveRoll = Mathf.Clamp(localFlyTarget.x, -1f, 1f);
            var wingsLevelRoll = transform.right.y;
            var wingsLevelInfluence = Mathf.InverseLerp(0f, aggressiveTurnAngle, angleOffTarget);
            roll = Mathf.Lerp(wingsLevelRoll, agressiveRoll, wingsLevelInfluence);
        }

        // --------------------------------------------------
        // State Calculations
        // --------------------------------------------------

        private void CalculateState(float dt)
        {
            var invRotation = Quaternion.Inverse(transform.rotation);
            Velocity = rigid.velocity;
            LocalVelocity = invRotation * Velocity;
            LocalAngularVelocity = invRotation * rigid.angularVelocity;
        }

        private void CalculateAngleOfAttack()
        {
            if (LocalVelocity.sqrMagnitude < 0.1f)
            {
                AngleOfAttack = 0;
                AngleOfAttackYaw = 0;
                return;
            }

            AngleOfAttack = Mathf.Atan2(-LocalVelocity.y, LocalVelocity.z);
            AngleOfAttackYaw = Mathf.Atan2(LocalVelocity.x, LocalVelocity.z);
        }

        private void CalculateGForce(float dt)
        {
            var invRotation = Quaternion.Inverse(rigid.rotation);
            var acceleration = (Velocity - lastVelocity) / dt;
            LocalGForce = invRotation * acceleration;
            lastVelocity = Velocity;
        }

        // --------------------------------------------------
        // Control and Steering
        // --------------------------------------------------

        private float CalculateSteering(float dt, float angularVelocity, float targetVelocity, float acceleration)
        {
            var error = targetVelocity - angularVelocity;
            var accel = acceleration * dt;
            return Mathf.Clamp(error, -accel, accel);
        }

        private float CalculateGLimiter(Vector3 controlInput, Vector3 maxAngularVelocity)
        {
            if (controlInput.magnitude < 0.01f)
                return 1;

            var maxInput = controlInput.normalized;
            var limit = CalculateGForceLimit(maxInput);
            var maxGForce = CalculateGForce(Vector3.Scale(maxInput, maxAngularVelocity), LocalVelocity);

            if (maxGForce.magnitude > limit.magnitude)
            {
                return limit.magnitude / maxGForce.magnitude;
            }
            return 1;
        }

        private Vector3 CalculateGForceLimit(Vector3 input)
        {
            return Utilities.Scale6(
                input,
                gLimit, gLimitPitch, 
                gLimit, gLimit, 
                gLimit, gLimit
            ) * 9.81f;
        }

        private Vector3 CalculateGForce(Vector3 angularVelocity, Vector3 velocity)
        {
            // G-Force estimation using cross product
            return Vector3.Cross(angularVelocity, velocity);
        }

        private void UpdateSteering(float dt)
        {
            var speed = Mathf.Max(0, LocalVelocity.z);
            float baseSteeringPower = 2.0f;
            float steeringPower = baseSteeringPower * (1.0f + speed / 100f); // Less control at higher speed

            var gForceScaling = CalculateGLimiter(controlInput, turnSpeed);
            var targetAV = Vector3.Scale(controlInput, turnSpeed * steeringPower * gForceScaling);
            var av = LocalAngularVelocity * Mathf.Rad2Deg;

            var correction = new Vector3(
                CalculateSteering(dt, av.x, targetAV.x, turnAcceleration.x),
                CalculateSteering(dt, av.y, targetAV.y, turnAcceleration.y),
                CalculateSteering(dt, av.z, targetAV.z, turnAcceleration.z)
            );

            rigid.AddRelativeTorque(correction * Mathf.Deg2Rad, ForceMode.VelocityChange);
        }

        // --------------------------------------------------
        // Aerodynamics
        // --------------------------------------------------

        private Vector3 CalculateLift(float angleOfAttack, Vector3 rightAxis, float currentLiftPower)
        {
            var liftVelocity = Vector3.ProjectOnPlane(LocalVelocity, rightAxis);
            var velocitySquared = liftVelocity.sqrMagnitude;

            // Simple lift coefficient calculation
            float liftCoefficient = Mathf.Clamp(1.0f + (0.1f * angleOfAttack), -1.5f, 1.5f);
            float liftForceMagnitude = velocitySquared * liftCoefficient * currentLiftPower;

            Vector3 liftDirection = Vector3.Cross(liftVelocity.normalized, rightAxis);
            return liftDirection * liftForceMagnitude;
        }

        private void UpdateLift()
        {
            if (LocalVelocity.sqrMagnitude < 1f) return;

            float appliedFlapsLiftPower = FlapsDeployed ? flapsLiftPower : 0;
            float appliedFlapsAOABias = FlapsDeployed ? flapsAOABias * Mathf.Deg2Rad : 0;

            var liftForce = CalculateLift(AngleOfAttack + appliedFlapsAOABias, Vector3.right, liftPower + appliedFlapsLiftPower);
            var yawForce = CalculateLift(AngleOfAttackYaw, Vector3.up, rudderPower);

            rigid.AddRelativeForce(liftForce);
            rigid.AddRelativeForce(yawForce);
        }

        private void UpdateThrust()
        {
            rigid.AddRelativeForce(thrust * maxThrust * Vector3.forward);
        }

        // --------------------------------------------------
        // Drag and Other Forces
        // --------------------------------------------------

        private void UpdateDrag()
        {
            var lv = LocalVelocity;
            var lv2 = lv.sqrMagnitude;

            float dragFactor = 2.0f;
            float currentAirbrakeDrag = AirbrakeDeployed ? this.airbrakeDrag : 0;
            float currentFlapsDrag = FlapsDeployed ? this.flapsDrag : 0;

            float dragX = dragFactor * Mathf.Abs(lv.x);
            float dragY = dragFactor * Mathf.Abs(lv.y);
            float dragZ = dragFactor * (Mathf.Abs(lv.z) + currentAirbrakeDrag + currentFlapsDrag);

            Vector3 dragForce = new Vector3(-dragX * lv.x, -dragY * lv.y, -dragZ * lv.z);
            rigid.AddRelativeForce(dragForce);
        }

        private void UpdateAngularDrag()
        {
            var av = LocalAngularVelocity;
            var drag = av.sqrMagnitude * -av.normalized; 
            rigid.AddRelativeTorque(Vector3.Scale(drag, angularDrag), ForceMode.Acceleration);
        }

        private void UpdateFlaps()
        {
            if (LocalVelocity.z > flapsRetractSpeed)
            {
                FlapsDeployed = false;
            }
        }
    }
}
