// //
// // Copyright (c) Brian Hernandez. All rights reserved.
// // Licensed under the MIT license. See LICENSE file in the project root for details.
// //

// using UnityEngine;

// namespace MFlight.Demo
// {
//     /// <summary>
//     /// This is a very demo-ey example of how to interpret the input generated by the
//     /// MouseFlightController. The plane flies towards the MouseAimPos automatically in
//     /// a similar fashion to how War Thunder's Instructor does it. There are also
//     /// keyboard overrides for flight control. It's not perfect, but it works well enough
//     /// for an example.
//     /// </summary>
//     [RequireComponent(typeof(Rigidbody))]
//     public class Plane : MonoBehaviour
//     {
//         [Header("Components")]
//         [SerializeField] private MouseFlightController controller = null;

//         [Header("Physics")]
//         [Tooltip("Force to push plane forwards with")] public float thrust = 100f;
//         [Tooltip("Pitch, Yaw, Roll")] public Vector3 turnTorque = new Vector3(90f, 25f, 45f);
//         [Tooltip("Multiplier for all forces")] public float forceMult = 1000f;

//         [Header("Autopilot")]
//         [Tooltip("Sensitivity for autopilot flight.")] public float sensitivity = 5f;
//         [Tooltip("Angle at which airplane banks fully into target.")] public float aggressiveTurnAngle = 10f;

//         [Header("Input")]
//         [SerializeField] [Range(-1f, 1f)] private float pitch = 0f;
//         [SerializeField] [Range(-1f, 1f)] private float yaw = 0f;
//         [SerializeField] [Range(-1f, 1f)] private float roll = 0f;

//         [Header("Aerodynamics")]
//         [Tooltip("Lift power of the plane.")]
//         public float liftPower = 5f;
//         [Tooltip("Drag induced by the lift.")]
//         public float inducedDrag = 0.05f;
//         [Tooltip("Animation curve for lift based on angle of attack.")]
//         public AnimationCurve liftAOACurve;
//         [Tooltip("Animation curve for drag induced by lift.")]
//         public AnimationCurve inducedDragCurve;
//         [Tooltip("Flaps lift power multiplier.")]
//         public float flapsLiftPower = 1.5f;
//         [Tooltip("Speed above which flaps automatically retract.")]
//         public float flapsRetractSpeed = 30f;

//         [Header("Flight Dynamics")]
//         [Tooltip("Curve for drag based on speed.")]
//         public AnimationCurve dragForward;
//         public AnimationCurve dragBack;
//         public AnimationCurve dragLeft;
//         public AnimationCurve dragRight;
//         public AnimationCurve dragTop;
//         public AnimationCurve dragBottom;

//         [Tooltip("Limits for G-force in flight.")]
//         public float gLimit = 9f;
//         public float gLimitPitch = 7f;

//         public float Pitch { set { pitch = Mathf.Clamp(value, -1f, 1f); } get { return pitch; } }
//         public float Yaw { set { yaw = Mathf.Clamp(value, -1f, 1f); } get { return yaw; } }
//         public float Roll { set { roll = Mathf.Clamp(value, -1f, 1f); } get { return roll; } }

//         private Rigidbody rigid;

//         private bool rollOverride = false;
//         private bool pitchOverride = false;
//         private bool flapsDeployed = false;

//         private void Awake()
//         {
//             rigid = GetComponent<Rigidbody>();

//             if (controller == null)
//                 Debug.LogError(name + ": Plane - Missing reference to MouseFlightController!");
//         }

//         private void Update()
//         {
//             // When the player commands their own stick input, it should override what the
//             // autopilot is trying to do.
//             rollOverride = false;
//             pitchOverride = false;

//             float keyboardRoll = Input.GetAxis("Horizontal");
//             if (Mathf.Abs(keyboardRoll) > .25f)
//             {
//                 rollOverride = true;
//             }

//             float keyboardPitch = Input.GetAxis("Vertical");
//             if (Mathf.Abs(keyboardPitch) > .25f)
//             {
//                 pitchOverride = true;
//                 rollOverride = true;
//             }

//             // Calculate the autopilot stick inputs.
//             float autoYaw = 0f;
//             float autoPitch = 0f;
//             float autoRoll = 0f;
//             if (controller != null)
//                 RunAutopilot(controller.MouseAimPos, out autoYaw, out autoPitch, out autoRoll);

//             // Use either keyboard or autopilot input.
//             yaw = autoYaw;
//             pitch = (pitchOverride) ? keyboardPitch : autoPitch;
//             roll = (rollOverride) ? keyboardRoll : autoRoll;

//             //controller= new Vector3(yaw, pitch, roll);
//         }

//         private void RunAutopilot(Vector3 flyTarget, out float yaw, out float pitch, out float roll)
//         {
//             // This is my usual trick of converting the fly to position to local space.
//             // You can derive a lot of information from where the target is relative to self.
//             var localFlyTarget = transform.InverseTransformPoint(flyTarget).normalized * sensitivity;
//             var angleOffTarget = Vector3.Angle(transform.forward, flyTarget - transform.position);

//             // IMPORTANT!
//             // These inputs are created proportionally. This means it can be prone to
//             // overshooting. The physics in this example are tweaked so that it's not a big
//             // issue, but in something with different or more realistic physics this might
//             // not be the case. Use of a PID controller for each axis is highly recommended.

//             // ====================
//             // PITCH AND YAW
//             // ====================

//             // Yaw/Pitch into the target so as to put it directly in front of the aircraft.
//             // A target is directly in front the aircraft if the relative X and Y are both
//             // zero. Note this does not handle for the case where the target is directly behind.
//             yaw = Mathf.Clamp(localFlyTarget.x, -1f, 1f);
//             pitch = -Mathf.Clamp(localFlyTarget.y, -1f, 1f);

//             // ====================
//             // ROLL
//             // ====================

//             // Roll is a little special because there are two different roll commands depending
//             // on the situation. When the target is off axis, then the plane should roll into it.
//             // When the target is directly in front, the plane should fly wings level.

//             // An "aggressive roll" is input such that the aircraft rolls into the target so
//             // that pitching up (handled above) will put the nose onto the target. This is
//             // done by rolling such that the X component of the target's position is zeroed.
//             var agressiveRoll = Mathf.Clamp(localFlyTarget.x, -1f, 1f);

//             // A "wings level roll" is a roll commands the aircraft to fly wings level.
//             // This can be done by zeroing out the Y component of the aircraft's right.
//             var wingsLevelRoll = transform.right.y;

//             // Blend between auto level and banking into the target.
//             var wingsLevelInfluence = Mathf.InverseLerp(0f, aggressiveTurnAngle, angleOffTarget);
//             roll = Mathf.Lerp(wingsLevelRoll, agressiveRoll, wingsLevelInfluence);
//         }

//         private void CalculateAngleOfAttack() {
//             Vector3 localVelocity = transform.InverseTransformDirection(rigid.velocity);
//             if (localVelocity.sqrMagnitude < 0.1f) return;

//             // Angle of attack calculation
//             var angleOfAttack = Mathf.Atan2(-localVelocity.y, localVelocity.z);
//             var angleOfAttackYaw = Mathf.Atan2(localVelocity.x, localVelocity.z);
//         }

//         private Vector3 CalculateLift(float angleOfAttack, Vector3 rightAxis) {
//         var localVelocity = transform.InverseTransformDirection(rigid.velocity);
//         var liftVelocity = Vector3.ProjectOnPlane(localVelocity, rightAxis);
//         var velocitySquared = liftVelocity.sqrMagnitude;

//         // Coefficient and lift force
//         var liftCoefficient = liftAOACurve.Evaluate(angleOfAttack * Mathf.Rad2Deg);
//         var liftForce = velocitySquared * liftCoefficient * liftPower;

//         // Lift direction
//         var liftDirection = Vector3.Cross(liftVelocity.normalized, rightAxis);
//         var lift = liftDirection * liftForce;

//         // Induced drag using the class-level variable
//         var dragForce = liftCoefficient * liftCoefficient;
//         var dragDirection = -liftVelocity.normalized;
//         var inducedDragForce = dragDirection * velocitySquared * dragForce * inducedDrag;

//         return lift + inducedDragForce;
//     }


//         private void UpdateLift() {
//             // Example lift application
//             float angleOfAttack = Mathf.Atan2(-rigid.velocity.y, rigid.velocity.z);
//             Vector3 lift = CalculateLift(angleOfAttack, Vector3.right);
//             rigid.AddForce(lift);
//         }

//         private void UpdateDrag() {
//             var localVelocity = transform.InverseTransformDirection(rigid.velocity);
//             var velocitySquared = localVelocity.sqrMagnitude;

//             // Coefficients of drag
//             var dragCoefficient = Utilities.Scale6(
//                 localVelocity.normalized,
//                 dragRight.Evaluate(Mathf.Abs(localVelocity.x)),
//                 dragLeft.Evaluate(Mathf.Abs(localVelocity.x)),
//                 dragTop.Evaluate(Mathf.Abs(localVelocity.y)),
//                 dragBottom.Evaluate(Mathf.Abs(localVelocity.y)),
//                 dragForward.Evaluate(Mathf.Abs(localVelocity.z)),
//                 dragBack.Evaluate(Mathf.Abs(localVelocity.z))
//             );

//         // Apply drag force
//         Vector3 drag = dragCoefficient.magnitude * velocitySquared * -localVelocity.normalized;
//         rigid.AddForce(drag);
//         }

//         private void UpdateFlaps() {
//             if (rigid.velocity.magnitude > flapsRetractSpeed) {
//                 flapsDeployed = false;
//             }
//         }

//         private void FixedUpdate() {
//         // Simuler la poussée simple
//         // rigid.AddRelativeForce(Vector3.forward * thrust * forceMult, ForceMode.Force);

//         // // // Appliquer le couple pour le contrôle
//         // rigid.AddRelativeTorque(new Vector3(turnTorque.x * pitch, turnTorque.y * yaw, -turnTorque.z * roll) * forceMult, ForceMode.Force);

//         // Calcul et application des forces aérodynamiques
//         UpdateLift();
//         UpdateDrag();
//         UpdateFlaps();
//         }

//     }
// }

using UnityEngine;
using System.Collections;
using System.Collections.Generic;

namespace MFlight.Demo
{
    /// <summary>
    /// This is a very demo-ey example of how to interpret the input generated by the
    /// MouseFlightController. The plane flies towards the MouseAimPos automatically in
    /// a similar fashion to how War Thunder's Instructor does it. There are also
    /// keyboard overrides for flight control. It's not perfect, but it works well enough
    /// for an example.
    /// </summary>
    [RequireComponent(typeof(Rigidbody))]
    public class Plane : MonoBehaviour
    {
        [Header("Components")]
        [SerializeField] private MouseFlightController controller = null;

        [Header("Physics")]
        [Tooltip("Force to push plane forwards with")] public float thrust = 50f;
        [Tooltip("Pitch, Yaw, Roll")] public Vector3 turnTorque = new Vector3(90f, 25f, 45f);
        [Tooltip("Multiplier for all forces")] public float forceMult = 1000f;

        [Header("Autopilot")]
        [Tooltip("Sensitivity for autopilot flight.")] public float sensitivity = 5f;
        [Tooltip("Angle at which airplane banks fully into target.")] public float aggressiveTurnAngle = 10f;

        [Header("Input")]
        [SerializeField] [Range(-1f, 1f)] private float pitch = 0f;
        [SerializeField] [Range(-1f, 1f)] private float yaw = 0f;
        [SerializeField] [Range(-1f, 1f)] private float roll = 0f;

        public float Pitch { set { pitch = Mathf.Clamp(value, -1f, 1f); } get { return pitch; } }
        public float Yaw { set { yaw = Mathf.Clamp(value, -1f, 1f); } get { return yaw; } }
        public float Roll { set { roll = Mathf.Clamp(value, -1f, 1f); } get { return roll; } }


        [Header("Flight Data")]
        [Tooltip("Maximum thrust the plane engine can provide")]
        public float maxThrust = 100f;

        public float Throttle = 50;
        private Vector3 Velocity;
        private Vector3 lastVelocity;
        private Vector3 LocalVelocity;
        private Vector3 LocalAngularVelocity;
        private Vector3 LocalGForce;

        private float AngleOfAttack;
        private float AngleOfAttackYaw;

        public bool AirbrakeDeployed = false;
        public bool FlapsDeployed = false;

        public float airbrakeDrag = 0.1f;
        public float flapsDrag = 0.2f;

        // public AnimationCurve dragRight;
        // public AnimationCurve dragLeft;
        // public AnimationCurve dragTop;
        // public AnimationCurve dragBottom;
        // public AnimationCurve dragForward;
        // public AnimationCurve dragBack;

        [Header("Aérodynamique Avancée")]
        public float inducedDrag = 0.05f;       // Valeur d'exemple
        public float flapsLiftPower = 0.5f;     // Valeur d'exemple
        public float flapsAOABias = 5f;         // Valeur d'exemple (en degrés probablement)
        public float liftPower = 1.0f;          // Valeur d'exemple
        // public AnimationCurve liftAOACurve;
        // public AnimationCurve inducedDragCurve;

        [Header("Gouvernes")]
        public float rudderPower = 0.5f;        // Valeur d'exemple
        // public AnimationCurve rudderAOACurve;
        // public AnimationCurve rudderInducedDragCurve;


        [Header("Contrôles Avancés")]
        // public AnimationCurve steeringCurve;    // Courbe déterminant la force de virage en fonction de la vitesse
        public Vector3 controlInput;            // Input de contrôle (pitch, yaw, roll normalisés)
        public float turnSpeed = 45f;           // Vitesse de rotation en degrés/s ou un facteur de vitesse
        public Vector3 turnAcceleration = new Vector3(10f, 10f, 10f); // Accélération angulaire
        public Vector3 EffectiveInput;          // Valeur finale des inputs après corrections

        [Header("Limites G")]
        public float gLimit = 8f;       // exemple : limite G générale
        public float gLimitPitch = 8f; 
        private Rigidbody rigid;
        public float initialSpeed=50;
        private bool rollOverride = false;
        private bool pitchOverride = false;

        private void Awake()
        {
            rigid = GetComponent<Rigidbody>();

            if (controller == null)
                Debug.LogError(name + ": Plane - Missing reference to MouseFlightController!");

        }

        private void Update()
        {
            // When the player commands their own stick input, it should override what the
            // autopilot is trying to do.
            rollOverride = false;
            pitchOverride = false;

            float keyboardRoll = Input.GetAxis("Horizontal");
            if (Mathf.Abs(keyboardRoll) > .1f)
            {
                rollOverride = true;
            }

            float keyboardPitch = Input.GetAxis("Vertical");
            if (Mathf.Abs(keyboardPitch) > .1f)
            {
                pitchOverride = true;
                rollOverride = true;
            }

            // Calculate the autopilot stick inputs.
            float autoYaw = 0f;
            float autoPitch = 0f;
            float autoRoll = 0f;
            if (controller != null)
                RunAutopilot(controller.MouseAimPos, out autoYaw, out autoPitch, out autoRoll);

            // Use either keyboard or autopilot input.
            yaw = autoYaw;
            pitch = (pitchOverride) ? keyboardPitch : autoPitch;
            roll = (rollOverride) ? keyboardRoll : autoRoll;
            controlInput = new Vector3(pitch, yaw, roll);
        }

        private void RunAutopilot(Vector3 flyTarget, out float yaw, out float pitch, out float roll)
        {
            // This is my usual trick of converting the fly to position to local space.
            // You can derive a lot of information from where the target is relative to self.
            var localFlyTarget = transform.InverseTransformPoint(flyTarget).normalized * sensitivity;
            var angleOffTarget = Vector3.Angle(transform.forward, flyTarget - transform.position);

            // IMPORTANT!
            // These inputs are created proportionally. This means it can be prone to
            // overshooting. The physics in this example are tweaked so that it's not a big
            // issue, but in something with different or more realistic physics this might
            // not be the case. Use of a PID controller for each axis is highly recommended.

            // ====================
            // PITCH AND YAW
            // ====================

            // Yaw/Pitch into the target so as to put it directly in front of the aircraft.
            // A target is directly in front the aircraft if the relative X and Y are both
            // zero. Note this does not handle for the case where the target is directly behind.
            yaw = Mathf.Clamp(localFlyTarget.x, -1f, 1f);
            pitch = -Mathf.Clamp(localFlyTarget.y, -1f, 1f);

            // ====================
            // ROLL
            // ====================

            // Roll is a little special because there are two different roll commands depending
            // on the situation. When the target is off axis, then the plane should roll into it.
            // When the target is directly in front, the plane should fly wings level.

            // An "aggressive roll" is input such that the aircraft rolls into the target so
            // that pitching up (handled above) will put the nose onto the target. This is
            // done by rolling such that the X component of the target's position is zeroed.
            var agressiveRoll = Mathf.Clamp(localFlyTarget.x, -1f, 1f);

            // A "wings level roll" is a roll commands the aircraft to fly wings level.
            // This can be done by zeroing out the Y component of the aircraft's right.
            var wingsLevelRoll = transform.right.y;

            // Blend between auto level and banking into the target.
            var wingsLevelInfluence = Mathf.InverseLerp(0f, aggressiveTurnAngle, angleOffTarget);
            roll = Mathf.Lerp(wingsLevelRoll, agressiveRoll, wingsLevelInfluence);
        }

        Vector3 CalculateGForce(Vector3 angularVelocity, Vector3 velocity) {
            //estiamte G Force from angular velocity and velocity
            //Velocity = AngularVelocity * Radius
            //G = Velocity^2 / R
            //G = (Velocity * AngularVelocity * Radius) / Radius
            //G = Velocity * AngularVelocity
            //G = V cross A
            return Vector3.Cross(angularVelocity, velocity);
        }

        Vector3 CalculateGForceLimit(Vector3 input) {
            return Utilities.Scale6(
                input,
                gLimit, gLimitPitch,   // floats
                gLimit, gLimit,        // floats
                gLimit, gLimit         // floats
            ) * 9.81f;
        }

        private float CalculateGLimiter(Vector3 controlInput, Vector3 maxAngularVelocity) {
            if (controlInput.magnitude < 0.01f) {
                return 1;
            }

            //if the player gives input with magnitude less than 1, scale up their input so that magnitude == 1
            var maxInput = controlInput.normalized;

            var limit = CalculateGForceLimit(maxInput);
            var maxGForce = CalculateGForce(Vector3.Scale(maxInput, maxAngularVelocity), LocalVelocity);

            if (maxGForce.magnitude > limit.magnitude) {
                //example:
                //maxGForce = 16G, limit = 8G
                //so this is 8 / 16 or 0.5
                return limit.magnitude / maxGForce.magnitude;
            }
            return 1;
        }

        
        private float CalculateSteering(float dt, float angularVelocity, float targetVelocity, float acceleration) {
            var error = targetVelocity - angularVelocity;
            var accel = acceleration * dt;
            return Mathf.Clamp(error, -accel, accel);
        }

        private void UpdateSteering(float dt)
        {
            var speed = Mathf.Max(0, LocalVelocity.z);
            float baseSteeringPower = 0.5f;        // Puissance de base pour le contrôle
            float steeringPower = baseSteeringPower * (1.0f + speed / 100f); // Plus de vitesse = moins de contrôle

            var gForceScaling = CalculateGLimiter(controlInput, Vector3.one * turnSpeed);
            var targetAV = Vector3.Scale(controlInput,  Vector3.one * turnSpeed * steeringPower * gForceScaling);

            var av = LocalAngularVelocity * Mathf.Rad2Deg;

            var correction = new Vector3(
                CalculateSteering(dt, av.x, targetAV.x, turnAcceleration.x),
                CalculateSteering(dt, av.y, targetAV.y, turnAcceleration.y),
                CalculateSteering(dt, av.z, targetAV.z, turnAcceleration.z)
            );

            rigid.AddRelativeTorque(correction * Mathf.Deg2Rad, ForceMode.VelocityChange);
        }

        // private void UpdateSteering(float dt) {
        //     var speed = Mathf.Max(0, LocalVelocity.z);
        //     //var steeringPower = steeringCurve.Evaluate(speed);
        //     var baseSteeringPower = 50f; // valeur minimale
        //     var steeringPower = baseSteeringPower + steeringCurve.Evaluate(speed);
        //     var gForceScaling = CalculateGLimiter(controlInput, Vector3.one * (turnSpeed * Mathf.Deg2Rad * steeringPower));

        //     var factor = turnSpeed * Mathf.Deg2Rad * steeringPower * gForceScaling;
        //     var targetAV = Vector3.Scale(controlInput, Vector3.one * factor);

        //     var av = LocalAngularVelocity * Mathf.Rad2Deg;

        //     var correction = new Vector3(
        //         CalculateSteering(dt, av.x, targetAV.x, turnAcceleration.x * steeringPower),
        //         CalculateSteering(dt, av.y, targetAV.y, turnAcceleration.y * steeringPower),
        //         CalculateSteering(dt, av.z, targetAV.z, turnAcceleration.z * steeringPower)
        //     );
        //     Debug.Log("Steering Power: " + steeringPower);

        //     rigid.AddRelativeTorque(correction * Mathf.Deg2Rad, ForceMode.VelocityChange);    //ignore rigidbody mass

        //     var correctionInput = new Vector3(
        //         Mathf.Clamp((targetAV.x - av.x) / turnAcceleration.x, -1, 1),
        //         Mathf.Clamp((targetAV.y - av.y) / turnAcceleration.y, -1, 1),
        //         Mathf.Clamp((targetAV.z - av.z) / turnAcceleration.z, -1, 1)
        //     );

        //     var effectiveInput = (correctionInput + controlInput) * gForceScaling;

        //     EffectiveInput = new Vector3(
        //         Mathf.Clamp(effectiveInput.x, -1, 1),
        //         Mathf.Clamp(effectiveInput.y, -1, 1),
        //         Mathf.Clamp(effectiveInput.z, -1, 1)
        //     );

        // }

        // Vector3 CalculateLift(float angleOfAttack, Vector3 rightAxis, float liftPower, AnimationCurve aoaCurve, AnimationCurve inducedDragCurve) {
        //     var liftVelocity = Vector3.ProjectOnPlane(LocalVelocity, rightAxis);    //project velocity onto YZ plane
        //     var v2 = liftVelocity.sqrMagnitude;                                     //square of velocity

        //     //lift = velocity^2 * coefficient * liftPower
        //     //coefficient varies with AOA
        //     var liftCoefficient = aoaCurve.Evaluate(angleOfAttack * Mathf.Rad2Deg);
        //     var liftForce = v2 * liftCoefficient * liftPower;

        //     //lift is perpendicular to velocity
        //     var liftDirection = Vector3.Cross(liftVelocity.normalized, rightAxis);
        //     var lift = liftDirection * liftForce;

        //     //induced drag varies with square of lift coefficient
        //     var dragForce = liftCoefficient * liftCoefficient;
        //     var dragDirection = -liftVelocity.normalized;
        //     var inducedDrag = dragDirection * v2 * dragForce * this.inducedDrag * inducedDragCurve.Evaluate(Mathf.Max(0, LocalVelocity.z));

        //     return lift + inducedDrag;
        // }

        // private void UpdateLift() {
        //     if (LocalVelocity.sqrMagnitude < 1f) return;

        //     float flapsLiftPower = FlapsDeployed ? this.flapsLiftPower : 0;
        //     float flapsAOABias = FlapsDeployed ? this.flapsAOABias : 0;

        //     var liftForce = CalculateLift(
        //         AngleOfAttack + (flapsAOABias * Mathf.Deg2Rad), Vector3.right,
        //         liftPower + flapsLiftPower,
        //         liftAOACurve,
        //         inducedDragCurve
        //     );

        //     var yawForce = CalculateLift(AngleOfAttackYaw, Vector3.up, rudderPower, rudderAOACurve, rudderInducedDragCurve);

        //     rigid.AddRelativeForce(liftForce);
        //     rigid.AddRelativeForce(yawForce);
        // }

        private Vector3 CalculateLift(float angleOfAttack, Vector3 rightAxis, float liftPower)
        {
            var liftVelocity = Vector3.ProjectOnPlane(LocalVelocity, rightAxis);
            var velocitySquared = liftVelocity.sqrMagnitude;

            // Coefficient de portance basé sur l'angle d'attaque
            float liftCoefficient = Mathf.Clamp(1.0f + (0.1f * angleOfAttack), -1.5f, 1.5f);

            // Calcul de la portance
            float liftForceMagnitude = velocitySquared * liftCoefficient * liftPower;

            // Direction de la portance
            Vector3 liftDirection = Vector3.Cross(liftVelocity.normalized, rightAxis);
            return liftDirection * liftForceMagnitude;
        }

        private void UpdateLift()
        {
            if (LocalVelocity.sqrMagnitude < 1f) return;

            float flapsLiftPower = FlapsDeployed ? this.flapsLiftPower : 0;
            float flapsAOABias = FlapsDeployed ? this.flapsAOABias * Mathf.Deg2Rad : 0;

            var liftForce = CalculateLift(AngleOfAttack + flapsAOABias, Vector3.right, liftPower + flapsLiftPower);
            var yawForce = CalculateLift(AngleOfAttackYaw, Vector3.up, rudderPower);

            rigid.AddRelativeForce(liftForce);
            rigid.AddRelativeForce(yawForce);
        }

        private void UpdateThrust()
        {
            rigid.AddRelativeForce(Throttle*maxThrust*Vector3.forward);

        }
        private void CalculateState(float dt)
        {
            var invRotation = Quaternion.Inverse(transform.rotation);
            Velocity = rigid.velocity;
            LocalVelocity = invRotation * Velocity;
            LocalAngularVelocity = invRotation * rigid.angularVelocity;
        }

        private void CalculateAngleOfAttack()
        {
            if(LocalVelocity.sqrMagnitude < 0.1f)
            {
                AngleOfAttack = 0;
                AngleOfAttackYaw = 0;
                return ;
            }

            AngleOfAttack = Mathf.Atan2(-LocalVelocity.y,LocalVelocity.z);
            AngleOfAttackYaw = Mathf.Atan2(LocalVelocity.x,LocalVelocity.z);
        }

        private void CalculateGForce(float dt)
        {
            var invRotation = Quaternion.Inverse(rigid.rotation);
            var acceleration = (Velocity - lastVelocity) / dt;
            LocalGForce = invRotation * acceleration;
            lastVelocity = Velocity;
        }

        // private void UpdateDrag()
        // {
        //     var lv = LocalVelocity;
        //     var lv2 = lv.sqrMagnitude;  //velocity squared

        //     float airbrakeDrag = AirbrakeDeployed ? this.airbrakeDrag : 0;
        //     float flapsDrag = FlapsDeployed ? this.flapsDrag : 0;

        //     //calculate coefficient of drag depending on direction on velocity
        //     var coefficient = Utilities.Scale6(
        //         lv.normalized,
        //         dragRight.Evaluate(Mathf.Abs(lv.x)), dragLeft.Evaluate(Mathf.Abs(lv.x)),                
        //         dragTop.Evaluate(Mathf.Abs(lv.y)), dragBottom.Evaluate(Mathf.Abs(lv.y)),
        //         dragForward.Evaluate(Mathf.Abs(lv.z)) + airbrakeDrag + flapsDrag,   //include extra drag for forward coefficient
        //         dragBack.Evaluate(Mathf.Abs(lv.z))
        //     );

        //     var drag = coefficient.magnitude * lv2 * -lv.normalized;    //drag is opposite direction of velocity

        //     rigid.AddRelativeForce(drag);
        // }
        
        private void UpdateDrag()
        {
            var lv = LocalVelocity;              // Vitesse locale
            var lv2 = lv.sqrMagnitude;           // Vitesse locale au carré (V^2)
            
            float dragFactor = 2.0f;            // Facteur de traînée globale (à ajuster pour plus de réalisme)
            float airbrakeDrag = AirbrakeDeployed ? this.airbrakeDrag : 0;
            float flapsDrag = FlapsDeployed ? this.flapsDrag : 0;

            // Coefficient de traînée simplifié selon chaque axe
            float dragX = dragFactor * Mathf.Abs(lv.x);
            float dragY = dragFactor * Mathf.Abs(lv.y);
            float dragZ = dragFactor * (Mathf.Abs(lv.z) + airbrakeDrag + flapsDrag);

            // Calcul de la force totale de traînée
            Vector3 dragForce = new Vector3(-dragX * lv.x, -dragY * lv.y, -dragZ * lv.z);
            rigid.AddRelativeForce(dragForce);
        }

        void UpdateFlaps() {
        if (LocalVelocity.z > flapsRetractSpeed) {
            FlapsDeployed = false;
        }
        }
        private void FixedUpdate()
        {
            float dt = Time.fixedDeltaTime;

            //calculate at start, to capture any changes that happened externally
            CalculateState(dt);
            CalculateAngleOfAttack();
            CalculateGForce(dt);
           // UpdateFlaps();

            //UpdateThrottle(dt);
            UpdateThrust();
            UpdateLift();
            UpdateSteering(dt);

            UpdateDrag();


            //calculate at end, to capture any changes that happened internally 
             CalculateState(dt);


        }
    
    }
}
